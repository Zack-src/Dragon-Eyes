
TODO

Cr√©er un outil capable de cartographier, analyser et recommander des am√©liorations pour du code C++ √† grande √©chelle, compatible avec les environnements de build les plus utilis√©s.
Le but est de faciliter le debug, la maintenance, et l'optimisation. Possibilit√© d'avoir cette outil directement int√©gr√© dans l'id√©e ou dans une page web local.

1. Mapper de code C++
Utilise libclang ou Clang AST pour :
   - Lister les classes, fonctions, variables globales, namespaces.
   - Identifier les appels directs et indirects (graph de call).
   - G√©n√©rer un plan visuel.
   - Identifier les zones mortes (fonctions inutilis√©es, variables non utilis√©es).
   - Possibilit√© d'avoir un affichage verticale ou Horizontal

2. Analyse de bugs potentiels
D√©tection :
   - De fuite m√©moire potentielle (new sans delete, utilisation apr√®s free).
   - De variable non initialis√©e.
   - D‚Äôutilisation dangereuse de pointeurs bruts.
   - De conditions logiques douteuses (if (a = b)).

3. Suggestions d‚Äôoptimisation
Recommandations :
   - Remplacement de std::vector par std::array si taille fixe.
   - Passage par r√©f√©rence ou rvalue si pertinent.
   - Utilisation abusive de virtual / h√©ritage inutile.
   - Boucles non vectoris√©es / non parall√©lisables.
   - Utilisation de mutex mal plac√©s.

4. Compatibilit√©
   - Visual Studio 
      + Parsing des fichiers .sln et .vcxproj
      + D√©tection des plateformes (x64, x86), configurations (Debug, Release).
   - CMake
      + Parsing de CMakeLists.txt, d√©tection des cibles (target_*)
      + Int√©gration directe avec CMake --trace ou CMakeFileAPI.

5. Additional
   - Score global de qualit√©
   - Comparaison entre commits / branch (am√©lioration ou d√©gradation du code)
   - Proposer √† l'utilisateur d'envoyer la diff√©rence de code sur un serveur pour am√©liorer le tool (g√©n√©ral ou par projet (ne plus demander pour ce projet / ne plus jamais demander))
   - Fichier save de projet
      + save un hash de tout les fichier
      + pour chaque fichier, garder les indications de bug / am√©liorations
      + save la map du code

-----


üß≠ Feuille de route du projet CppInsight
üîπ Phase 0 ‚Äì Initialisation (1-2 jours)
Objectifs :
D√©finir le p√©rim√®tre pr√©cis.

Cr√©er la base du d√©p√¥t Git.

Actions :
Choisir un nom de projet (ex : CppInsight).

Cr√©er le d√©p√¥t GitHub avec :

README

Licence (MIT, Apache 2.0‚Ä¶)

Organisation dossier (src, include, tests, docs, scripts, etc.).

Initialiser un CMakeLists.txt propre et minimal.

üîπ Phase 1 ‚Äì Foundation & Parser Clang (1-2 semaines)
Objectifs :
Int√©grer libclang pour analyser le code.

Extraire les symboles (fonctions, classes, variables).

Livrables :
Un outil CLI (cppinsight analyze) capable de :

Charger un fichier .cpp ou projet .sln/CMake.

Extraire et afficher : liste des fichiers, fonctions, classes, variables globales.

Outils :
libclang

clang-c API (bindings si n√©cessaire)

üîπ Phase 2 ‚Äì G√©n√©rateur de cartographie (1-2 semaines)
Objectifs :
Repr√©senter graphiquement la structure du projet.

Livrables :
Fichiers .dot (pour graphviz) ou JSON hi√©rarchique pour frontend futur.

CLI : cppinsight map --output map.dot

Possibilit√© de naviguer les d√©pendances de fichiers, appels de fonctions.

Bonus :
G√©n√©rer un PNG ou SVG via Graphviz (dot -Tsvg).

üîπ Phase 3 ‚Äì Analyse de bugs potentiels (2 semaines)
Objectifs :
D√©tecter les erreurs classiques √† la compilation et au runtime.

Livrables :
CLI : cppinsight lint ou cppinsight analyze --bugs

Moteurs int√©gr√©s :

Wrapper autour de CppCheck / Clang-Tidy.

Analyse custom (ex : pointeur sans null-check, fuite m√©moire simple).

Techniques :
Analyse statique par pattern.

Heuristiques simples (par exemple : new sans delete).

üîπ Phase 4 ‚Äì Suggestions d‚Äôoptimisation (2-3 semaines)
Objectifs :
D√©tecter les endroits o√π le code peut √™tre optimis√©.

Livrables :
CLI : cppinsight optimize

Recommandations typiques :

R√©f√©rences au lieu de copies.

Variables inutilis√©es.

Boucles am√©liorables.

Containers mal choisis.

Techniques :
Analyse de l‚ÄôAST Clang.

D√©tection de motifs inefficaces.

üîπ Phase 5 ‚Äì Compatibilit√© Visual Studio / CMake (2 semaines)
Objectifs :
Permettre une analyse automatique selon le syst√®me de build.

Visual Studio :
Parsing .sln et .vcxproj.

D√©tection des plateformes (x64, x86) et configurations.

Extraction des chemins d‚Äôinclude et options du compilateur.

CMake :
Utilisation de cmake --trace-expand ou CMakeFileAPI.

Parsing des cibles.

üîπ Phase 6 ‚Äì G√©n√©ration de rapports (1 semaine)
Objectifs :
Exporter les r√©sultats lisiblement.

Livrables :
Rapport HTML avec :

Score global.

Liste des probl√®mes.

Cartographie interactive (si tu veux ajouter du JS plus tard).

Option : JSON complet pour int√©gration CI/CD.

üîπ Phase 7 ‚Äì Tests, packaging, documentation (1 semaine)
Objectifs :
Stabiliser le projet et pr√©parer la release alpha.

Livrables :
Tests unitaires (GoogleTest ou doctest).

Script install.sh / setup.ps1.

Documentation markdown :

README clair

Guide d‚Äôutilisation

Exemple d‚Äôanalyse

üîπ Phase 8 ‚Äì Publication et valorisation (en continu)
Objectifs :
Cr√©er une vraie pr√©sence open source.

Actions :
Mettre un logo.

Ajouter un GitHub Actions pour build/test.

R√©diger un post de pr√©sentation (Reddit, HackerNews, Dev.to‚Ä¶).

Pr√©parer une v1.0 stable.